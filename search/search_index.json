{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Kotlin PEG parser with Kotlin DSL ! The project is inspired by the pest parser and the kotlin-peg-dsl project . Simple example \u2693\ufe0e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 val num = Symbol . rule < Int > ( name = \"Num\" , ignoreWS = false ) { seq { val sign = + char ( '+' , '-' ). orDefault ( '+' ) val digits = + DIGIT . oneOrMore (). joinToString () value { ( sign . get + digits . get ). toInt () } } } val sum = Symbol . rule < Int > ( name = \"Sum\" ) { num . list ( separator = char ( '+' ), min = 1 u ). mapPe { it . sum () } } fun evalExpr ( expression : String ) = PegParser . parse ( symbol = sum . value (), expression ). getOrElse { null } val results = listOf ( evalExpr ( \"1\" ), // 1 evalExpr ( \"+1\" ), // 1 evalExpr ( \"+ 1\" ), // null evalExpr ( \"+1 +\" ), // null evalExpr ( \"-17\" ), // -17 evalExpr ( \"-1 7\" ), // null evalExpr ( \"1+2+3+4+5\" ), // 15 evalExpr ( \"1 + +2 + -3 + +4 + 5\" ), // 9 evalExpr ( \"definitely not expression\" ), // null evalExpr ( \"\" ), // null ) for ( res in results ) { println ( res ) } Resources \u2693\ufe0e Documentation Examples Simple calculator Json parser About PEG PEG formal description Other useful papers Things to improve before stable : \u2693\ufe0e TODO add more docs add more tests, improve the code coverage add more built-in characters add ability to define Comment parsing expression better error messages and error handling support left recursion provide more examples multiplatform Suggestions are welcome!","title":"Home"},{"location":"#simple-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 val num = Symbol . rule < Int > ( name = \"Num\" , ignoreWS = false ) { seq { val sign = + char ( '+' , '-' ). orDefault ( '+' ) val digits = + DIGIT . oneOrMore (). joinToString () value { ( sign . get + digits . get ). toInt () } } } val sum = Symbol . rule < Int > ( name = \"Sum\" ) { num . list ( separator = char ( '+' ), min = 1 u ). mapPe { it . sum () } } fun evalExpr ( expression : String ) = PegParser . parse ( symbol = sum . value (), expression ). getOrElse { null } val results = listOf ( evalExpr ( \"1\" ), // 1 evalExpr ( \"+1\" ), // 1 evalExpr ( \"+ 1\" ), // null evalExpr ( \"+1 +\" ), // null evalExpr ( \"-17\" ), // -17 evalExpr ( \"-1 7\" ), // null evalExpr ( \"1+2+3+4+5\" ), // 15 evalExpr ( \"1 + +2 + -3 + +4 + 5\" ), // 9 evalExpr ( \"definitely not expression\" ), // null evalExpr ( \"\" ), // null ) for ( res in results ) { println ( res ) }","title":"Simple example"},{"location":"#resources","text":"Documentation Examples Simple calculator Json parser About PEG PEG formal description Other useful papers","title":"Resources"},{"location":"#things-to-improve-before-stable","text":"TODO add more docs add more tests, improve the code coverage add more built-in characters add ability to define Comment parsing expression better error messages and error handling support left recursion provide more examples multiplatform Suggestions are welcome!","title":"Things to improve before stable:"},{"location":"pages/installation-guide/","text":"Installation guide \u2693\ufe0e Gradle \u2693\ufe0e Use Maven Central repository: 1 2 3 repositories { mavenCentral () } Kotlin DSL 1 2 3 dependencies { implementation ( \"io.kpeg:kpeg:0.1.0\" ) } Groovy DSL 1 2 3 dependencies { implementation 'io.kpeg:kpeg:0.1.0' } Maven \u2693\ufe0e 1 2 3 4 5 <dependency> <groupId> io.kpeg </groupId> <artifactId> kpeg </artifactId> <version> 0.1.0 </version> </dependency>","title":"Installation guide"},{"location":"pages/installation-guide/#installation-guide","text":"","title":"Installation guide"},{"location":"pages/installation-guide/#gradle","text":"Use Maven Central repository: 1 2 3 repositories { mavenCentral () } Kotlin DSL 1 2 3 dependencies { implementation ( \"io.kpeg:kpeg:0.1.0\" ) } Groovy DSL 1 2 3 dependencies { implementation 'io.kpeg:kpeg:0.1.0' }","title":"Gradle"},{"location":"pages/installation-guide/#maven","text":"1 2 3 4 5 <dependency> <groupId> io.kpeg </groupId> <artifactId> kpeg </artifactId> <version> 0.1.0 </version> </dependency>","title":"Maven"},{"location":"pages/user-guide/","text":"User guide \u2693\ufe0e This is only a user guide, after reading it, it's recommended that you also read KDoc . What is PEG ? \u2693\ufe0e From Wikipedia : In computer science, a parsing expression grammar ( PEG ), is a type of analytic formal grammar, i.e. it describes a formal language in terms of a set of rules for recognizing strings in the language. How to use kpeg ? \u2693\ufe0e Info kpeg is a PEG parser, not PEG parser generator. To use it you need to follow these simple steps: 1. Define your grammar and objects \u2693\ufe0e Grammar 1 2 3 4 5 6 7 8 9 10 object MyGrammar { val MySymbol : EvalSymbol < MyObj > = Symbol . lazyRule ( name = \"MySymbol\" ) { /* PE */ } private val A : EvalSymbol < Int > = Symbol . lazyRule ( name = \"A\" ) { /* PE */ } private val B : EvalSymbol < BObj > = Symbol . lazyRule ( name = \"B\" ) { /* PE */ } private val C : EvalSymbol < String > = Symbol . lazyRule ( name = \"C\" ) { /* PE */ } } Objects 1 2 3 data class MyObj ( val a : Int , val b : BObj , val c : String ) data class BObj ( val p : Double , val q : String ) 2. Define a utility function for parsing \u2693\ufe0e 1 fun parseMySymbol ( text : String ) = PegParser . parse ( symbol = MyGrammar . MySymbol , text ) 3. Use it \u2693\ufe0e 1 2 3 4 5 fun main () { val result = parseMySymbol ( text = \"your text\" ) println ( result ) } How to define a Symbol ? \u2693\ufe0e The definition of a Symbol is a Rule . To write a rule you need to use one of the two available factory methods: Symbol . lazyRule Creates symbols lazily , so the order in which they are declared does not matter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 object MyGrammar { val MarkedPersonSym = Symbol . lazyRule ( name = \"MarkedPersonSym\" ) { // `Operators` scope // Any available operator, e.g. a sequence: seq < Pair < String , Char >> { // `SequenceBuilder<Pair<String, Char>>` : `Operators` scope val person = + PersonSym val mark = + MarkSym value { person to mark } } } val PersonSym = Symbol . lazyRule ( name = \"PersonSym\" ) { // `Operators` scope // Any available operator, e.g. a literal: literal ( \"Alice\" ) } val MarkSym = Symbol . lazyRule ( name = \"MarkSym\" ) { // `Operators` scope // Any available operator, e.g. a character: char ( 'A' ) } } Symbol . rule Unlike its lazy counterpart, Symbol . rule creates symbols in eager fashion , so the order in which they are declared is of particular importance. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 object MyGrammar { val PersonSym = Symbol . rule ( name = \"PersonSym\" ) { // `Operators` scope // Any available operator, e.g. a literal: literal ( \"Alice\" ) } val MarkSym = Symbol . rule ( name = \"MarkSym\" ) { // `Operators` scope // Any available operator, e.g. a character: char ( 'A' ) } val MarkedPersonSym = Symbol . rule ( name = \"MarkedPersonSym\" ) { // `Operators` scope // Any available operator, e.g. a sequence: seq < Pair < String , Char >> { // `SequenceBuilder<Pair<String, Char>>` : `Operators` scope val person = + PersonSym val mark = + MarkSym value { person to mark } } } } Tip It's recommended to use Symbol . lazyRule because of its high versatility and low probability of unexpected errors. Library operators and their comparison with the classic PEG syntax \u2693\ufe0e Info The list below describes only those operators that have an analogy in the classic PEG syntax. A complete list of all available operators can be found here (KDoc) . Library operator Analogy of the classic PEG syntax Description char ( Char ) ' ' Character char ( Char , Char , ...) One of the characters char { ( Char ) -> Boolean } Character described by the block char ( CharRange ) [ ] Character class literal ( String ) \" \" Literal string literal { ( String ) -> Boolean } Literal string described by the block ANY . Any character ( PE ) (e) Grouping PE . optional () e? Optional PE . zeroOrMore () e* Zero-or-more PE . oneOrMore () e+ One-or-more and ( PE ) &e And-predicate not ( PE ) !e Not-predicate seq { ... } e 1 e 2 ... e n Sequence choice ( PE , PE , ...) e 1 / e 2 / ... / e n Prioritized choice Please share your ideas \u2693\ufe0e The lib is currently not promises backward-compatability , so feel free to pull request . Need help? \u2693\ufe0e For more in-depth documentation, see the KDoc . If you have any questions left, please, feel free to ask them here .","title":"User guide"},{"location":"pages/user-guide/#user-guide","text":"This is only a user guide, after reading it, it's recommended that you also read KDoc .","title":"User guide"},{"location":"pages/user-guide/#what-is-peg","text":"From Wikipedia : In computer science, a parsing expression grammar ( PEG ), is a type of analytic formal grammar, i.e. it describes a formal language in terms of a set of rules for recognizing strings in the language.","title":"What is PEG?"},{"location":"pages/user-guide/#how-to-use-kpeg","text":"Info kpeg is a PEG parser, not PEG parser generator. To use it you need to follow these simple steps:","title":"How to use kpeg?"},{"location":"pages/user-guide/#1-define-your-grammar-and-objects","text":"Grammar 1 2 3 4 5 6 7 8 9 10 object MyGrammar { val MySymbol : EvalSymbol < MyObj > = Symbol . lazyRule ( name = \"MySymbol\" ) { /* PE */ } private val A : EvalSymbol < Int > = Symbol . lazyRule ( name = \"A\" ) { /* PE */ } private val B : EvalSymbol < BObj > = Symbol . lazyRule ( name = \"B\" ) { /* PE */ } private val C : EvalSymbol < String > = Symbol . lazyRule ( name = \"C\" ) { /* PE */ } } Objects 1 2 3 data class MyObj ( val a : Int , val b : BObj , val c : String ) data class BObj ( val p : Double , val q : String )","title":"1. Define your grammar and objects"},{"location":"pages/user-guide/#2-define-a-utility-function-for-parsing","text":"1 fun parseMySymbol ( text : String ) = PegParser . parse ( symbol = MyGrammar . MySymbol , text )","title":"2. Define a utility function for parsing"},{"location":"pages/user-guide/#3-use-it","text":"1 2 3 4 5 fun main () { val result = parseMySymbol ( text = \"your text\" ) println ( result ) }","title":"3. Use it"},{"location":"pages/user-guide/#how-to-define-a-symbol","text":"The definition of a Symbol is a Rule . To write a rule you need to use one of the two available factory methods: Symbol . lazyRule Creates symbols lazily , so the order in which they are declared does not matter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 object MyGrammar { val MarkedPersonSym = Symbol . lazyRule ( name = \"MarkedPersonSym\" ) { // `Operators` scope // Any available operator, e.g. a sequence: seq < Pair < String , Char >> { // `SequenceBuilder<Pair<String, Char>>` : `Operators` scope val person = + PersonSym val mark = + MarkSym value { person to mark } } } val PersonSym = Symbol . lazyRule ( name = \"PersonSym\" ) { // `Operators` scope // Any available operator, e.g. a literal: literal ( \"Alice\" ) } val MarkSym = Symbol . lazyRule ( name = \"MarkSym\" ) { // `Operators` scope // Any available operator, e.g. a character: char ( 'A' ) } } Symbol . rule Unlike its lazy counterpart, Symbol . rule creates symbols in eager fashion , so the order in which they are declared is of particular importance. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 object MyGrammar { val PersonSym = Symbol . rule ( name = \"PersonSym\" ) { // `Operators` scope // Any available operator, e.g. a literal: literal ( \"Alice\" ) } val MarkSym = Symbol . rule ( name = \"MarkSym\" ) { // `Operators` scope // Any available operator, e.g. a character: char ( 'A' ) } val MarkedPersonSym = Symbol . rule ( name = \"MarkedPersonSym\" ) { // `Operators` scope // Any available operator, e.g. a sequence: seq < Pair < String , Char >> { // `SequenceBuilder<Pair<String, Char>>` : `Operators` scope val person = + PersonSym val mark = + MarkSym value { person to mark } } } } Tip It's recommended to use Symbol . lazyRule because of its high versatility and low probability of unexpected errors.","title":"How to define a Symbol?"},{"location":"pages/user-guide/#library-operators-and-their-comparison-with-the-classic-peg-syntax","text":"Info The list below describes only those operators that have an analogy in the classic PEG syntax. A complete list of all available operators can be found here (KDoc) . Library operator Analogy of the classic PEG syntax Description char ( Char ) ' ' Character char ( Char , Char , ...) One of the characters char { ( Char ) -> Boolean } Character described by the block char ( CharRange ) [ ] Character class literal ( String ) \" \" Literal string literal { ( String ) -> Boolean } Literal string described by the block ANY . Any character ( PE ) (e) Grouping PE . optional () e? Optional PE . zeroOrMore () e* Zero-or-more PE . oneOrMore () e+ One-or-more and ( PE ) &e And-predicate not ( PE ) !e Not-predicate seq { ... } e 1 e 2 ... e n Sequence choice ( PE , PE , ...) e 1 / e 2 / ... / e n Prioritized choice","title":"Library operators and their comparison with the classic PEG syntax"},{"location":"pages/user-guide/#please-share-your-ideas","text":"The lib is currently not promises backward-compatability , so feel free to pull request .","title":"Please share your ideas"},{"location":"pages/user-guide/#need-help","text":"For more in-depth documentation, see the KDoc . If you have any questions left, please, feel free to ask them here .","title":"Need help?"},{"location":"pages/examples/json/","text":"Json parser \u2693\ufe0e Docs are under development, for now you can dive into its sources here .","title":"Json parser"},{"location":"pages/examples/json/#json-parser","text":"Docs are under development, for now you can dive into its sources here .","title":"Json parser"},{"location":"pages/examples/simple-calc/","text":"Simple calculator \u2693\ufe0e Docs are under development, for now you can dive into its sources here .","title":"Simple calculator"},{"location":"pages/examples/simple-calc/#simple-calculator","text":"Docs are under development, for now you can dive into its sources here .","title":"Simple calculator"}]}